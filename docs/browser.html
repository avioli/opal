<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <title>Opal In The Browser</title>

  <link rel="stylesheet" href="../css/styles.css" type="text/css" media="screen" charset="utf-8">
  <link rel="stylesheet" href="../css/syntax.css" type="text/css" media="screen" charset="utf-8">
</head>
<body>
  <div class="content">
    <header>
      <nav>
        <ul>
          <li><a href="../docs.html">Back to Documentation</a></li>
        </ul>
      </nav>
    </header>
    <h1 id='opal_in_the_browser'>Opal In The Browser</h1>

<p>Opals primary platform is the browser, and the runtime has a number of components used to similate a ruby environment. To run ruby in the browser, the best practice is to compile files ahead of time, into javascript, which makes the runtime qucik and efficient. Opal offers an external API to make it easy to register and load these compiled libraries to make opal act like any other ruby runtime.</p>

<h2 id='overview_of_opal_api'>Overview of Opal API</h2>

<p>Once opal.js is loaded in the browser, it exposes only one global variable, <code>opal</code>. This namespace holds all the APIs needed to register and load files.</p>

<h3 id='runtime'>runtime</h3>

<p>The <code>runtime</code> property of the opal variable is where all the core runtime features of the ruby langaige are stored - this is what is passed directly into each function to allow ruby code to access the opal runtime to define classes, define methods, etc.</p>

<p>Most functions and properties of runtime should not be used directly as they are purely aimed for use by code generated by the opal compiler.</p>

<h3 id='compile'>compile</h3>

<p>The compile function on opal is a simple javascript function that will compile a string of ruby code and return a string representation of the javascript that can be run through opal. This function is only provided once <code>opal-parser.js</code> is loaded, so just throws an error by default. <code>opal-parser.js</code> should always be loaded after opal.js.</p>

<p>This function can be used simply from any browser debugger like:</p>
<div class='highlight'><pre><code class='javascript'><span class='nx'>opal</span><span class='p'>.</span><span class='nx'>compile</span><span class='p'>(</span><span class='s2'>&quot;some ruby code&quot;</span><span class='p'>);</span>
<span class='c1'>// =&gt; &quot;function() { ...js code... }&quot;</span>
</code></pre>
</div>
<h3 id='fs'>fs</h3>

<p>The <code>fs</code> namespace holds various functions and properties that are used to simulate a filesystem. Browsers do not have access to the local file system, so opal simulates one which has no files (by default). Files can be registered and added to this fake file system (see later), which allows the usual ruby <code>File</code> and <code>Dir</code> classes to operate.</p>

<p>This namespace also supports a <code>cwd</code> property which stores the fake current working directory of the application. This is useful for some ruby libraries such as testing frameworks which rely on a current working directory to find relevant test files.</p>

<p>Again, this is mostly used internally so should not need to be accessed manually.</p>

<h3 id='require'>require</h3>

<p>The <code>require</code> function is a quick way to require a lib in opal. This links directly with the ruby implementation to try and load a library at the given path. If successfull, <code>true</code> is returned. If the lib has already been loaded then <code>false</code> is returned as per ruby. If the lib cannot be found then an error is thrown. These errors, while ruby errors, are just regular javascript errors so can be caught and handled easily.</p>

<p>To require a lib, it must be predefined. This is done with the methods that follow which register them into the previously mentioned &#8220;fake&#8221; file system. <code>require</code> simply locates the file in the fake file system and then executes its body (which will be a function) and then just returns a true or false result. No XHR or similar methods are used during this process.</p>
<div class='highlight'><pre><code class='javascript'><span class='nx'>opal</span><span class='p'>.</span><span class='nx'>require</span><span class='p'>(</span><span class='s2'>&quot;my_lib/builder&quot;</span><span class='p'>);</span>
<span class='c1'>// =&gt; true</span>
<span class='nx'>opal</span><span class='p'>.</span><span class='nx'>require</span><span class='p'>(</span><span class='s2'>&quot;my_lib/builder&quot;</span><span class='p'>);</span>
<span class='c1'>// =&gt; false</span>
<span class='nx'>opal</span><span class='p'>.</span><span class='nx'>require</span><span class='p'>(</span><span class='s2'>&quot;some_non_existant_lib&quot;</span><span class='p'>);</span>
<span class='c1'>// =&gt; thrown Exception</span>
</code></pre>
</div>
<h3 id='cache'>cache</h3>

<p>The cache property is simply used to store a list of libs already loaded. When a lib is located, this cache is checked to make sure opal is not trying to require the same file twice.</p>

<h3 id='lib'>lib</h3>

<p>The lib function is used to register a compiled ruby file using the given lib name and a given body. Constructing this call should not be done manually as the opal build tools will do this with files you compile. The lib name should be the name of the file as it should be loaded with, i.e. it does not include a preceding path and it does not contain the ruby file extension.</p>

<p>For example, to register the &#8220;my_lib/builder&#8221; file used above:</p>
<div class='highlight'><pre><code class='javascript'><span class='nx'>opal</span><span class='p'>.</span><span class='nx'>lib</span><span class='p'>(</span><span class='s2'>&quot;my_lib/builder&quot;</span><span class='p'>,</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>$rb</span><span class='p'>,</span> <span class='nx'>self</span><span class='p'>,</span> <span class='nx'>__FILE__</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// ruby code</span>
<span class='p'>});</span>
</code></pre>
</div>
<p>This will register the lib file with a full path of &#8220;/lib/my_lib/builder.rb&#8221; and that file will then exist in the fake file system. All registered libs using this function will gain this preceding &#8220;/lib&#8221; path.</p>

<h3 id='gem'>gem</h3>

<p>For more complex file registering, the <code>gem</code> function is used. This is the result of using <code>Opal::Bundle</code> which registers either a gem or a similar app structure ready for opal. <code>Bundle</code> will compile a gem/app with all of its lib files into an js object which is passed to this function. The object will contain a <code>name</code> and <code>version</code> property which are gathered from a gems&#8217; gemspec or its overriden properties (in a rake task for instance).</p>

<p>An example for a made up library may look like the following:</p>
<div class='highlight'><pre><code class='javascript'><span class='nx'>opal</span><span class='p'>.</span><span class='nx'>gem</span><span class='p'>({</span>
  <span class='s2'>&quot;name&quot;</span><span class='o'>:</span> <span class='s2'>&quot;some_lib&quot;</span><span class='p'>,</span>
  <span class='s2'>&quot;version&quot;</span><span class='o'>:</span> <span class='s2'>&quot;0.0.1&quot;</span><span class='p'>,</span>
  <span class='s2'>&quot;libs&quot;</span><span class='o'>:</span> <span class='p'>{</span>
    <span class='s2'>&quot;some_lib&quot;</span><span class='o'>:</span> <span class='kd'>function</span><span class='p'>()</span> <span class='p'>{</span> <span class='cm'>/* implementation */</span> <span class='p'>},</span>
    <span class='s2'>&quot;some_lib/foo&quot;</span><span class='o'>:</span> <span class='kd'>function</span><span class='p'>()</span> <span class='p'>{</span> <span class='cm'>/* implementation */</span> <span class='p'>},</span>
    <span class='s2'>&quot;some_lib/bar&quot;</span><span class='o'>:</span> <span class='kd'>function</span><span class='p'>()</span> <span class='p'>{</span> <span class='cm'>/* implementation */</span> <span class='p'>}</span>
  <span class='p'>}</span>
<span class='p'>});</span>
</code></pre>
</div>
<p>The <code>libs</code> object contains a hash of all libs, which may be required, and all their respective (compiled) ruby functions. Each of these files is added to the fake file system using both their names, but also the gem name is used to prefix them so that they dont clash with other gems. The full file paths for these files will be: &#8220;/some_lib/lib/some_lib.rb&#8221;, &#8220;/some_lib/lib/some_lib/foo.rb&#8221;, and &#8220;/some_lib/lib/some_lib/bar.rb&#8221; respectively.</p>

<p>Again, this function isnt really there to be used manually, but is used from compiled gems to register themselves. It is also obvious that the files must be defined before they can be required.</p>

<h3 id='loader'>loader</h3>

<p>The <code>loader</code> property holds everything needed for resolving and loading required files. It has a few important properties itself:</p>

<h4 id='paths'>paths</h4>

<p>This is an array of all the load paths. As gems are registered their &#8216;lib&#8217; directories are added to this array. Also, the &#8220;/lib&#8221; directory is also in this so that all single registered libs can be loaded directly. This array is then exposed into ruby under the usual <code>$:</code> and <code>$LOAD\_PATH</code> globals.</p>

<h4 id='libs'>libs</h4>

<p>This is a javascript object of all registered libs to their full paths. These are libs registered with <code>lib</code> and with <code>gem</code>. The keys are the lib names, i.e. the name used in <code>require()</code> which can be used to require the file. These are stored here to make resolving much quicker than going through all load paths. Once the full path is retrieved then it is simply loaded (as below) and the implementation run. An example of this object, based on the gem above, may look like:</p>
<div class='highlight'><pre><code class='javascript'><span class='nx'>opal</span><span class='p'>.</span><span class='nx'>loader</span><span class='p'>.</span><span class='nx'>paths</span> <span class='o'>=</span> <span class='p'>{</span>
  <span class='s2'>&quot;some_lib&quot;</span><span class='o'>:</span> <span class='s2'>&quot;/some_lib/lib/some_lib.rb&quot;</span><span class='p'>,</span>
  <span class='s2'>&quot;some_lib/foo&quot;</span><span class='o'>:</span> <span class='s2'>&quot;/some_lib/lib/some_lib/foo.rb&quot;</span><span class='p'>,</span>
  <span class='s2'>&quot;some_lib/bar&quot;</span><span class='o'>:</span> <span class='s2'>&quot;/some_lib/lib/some_lib/bar.rb&quot;</span>
<span class='p'>};</span>
</code></pre>
</div>
<h4 id='factories'>factories</h4>

<p>The <code>factories</code> property contains all registered files, not just registered libs. It is a javascript object with all full paths as keys and implmentations as values. These keys make up the faked file system, so all ruby libraries like <code>File</code> and <code>Dir</code> use this object to simulate a file system. The registered gem as above will result in factories like:</p>
<div class='highlight'><pre><code class='javascript'><span class='nx'>opal</span><span class='p'>.</span><span class='nx'>loader</span><span class='p'>.</span><span class='nx'>factories</span> <span class='o'>=</span> <span class='p'>{</span>
  <span class='s2'>&quot;/some_lib/lib/some_lib.rb&quot;</span><span class='o'>:</span> <span class='kd'>function</span><span class='p'>()</span> <span class='p'>{</span> <span class='cm'>/* implementation */</span> <span class='p'>},</span>
  <span class='s2'>&quot;/some_lib/lib/some_lib/foo.rb&quot;</span><span class='o'>:</span> <span class='kd'>function</span><span class='p'>()</span> <span class='p'>{</span> <span class='cm'>/* implementation */</span> <span class='p'>},</span>
  <span class='s2'>&quot;/some_lib/lib/some_lib/bar.rb&quot;</span><span class='o'>:</span> <span class='kd'>function</span><span class='p'>()</span> <span class='p'>{</span> <span class='cm'>/* implementation */</span> <span class='p'>}</span>
<span class='p'>};</span>
</code></pre>
</div>
  </div>
</body>
</html>

